curl 'http://localhost:3000/api/set-fiddle' -H 'User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:63.0) Gecko/20100101 Firefox/63.0' -H 'Accept: */*' -H 'Accept-Language: en-US,en;q=0.5' --compressed -H 'Referer: https://studio.nearprotocol.com/?f=dxopmnspumb' -H 'content-type: application/json; charset=utf-8' -H 'origin: https://studio.nearprotocol.com' -H 'Connection: keep-alive' --data $'{"files":[{"name":"README.md","data":"# Hello World in C\\n\\nLevel: *Advanced*\\n\\nThis project prints `\\"Hello World\\"` using the well known C `printf` function. This function in turn uses several POSIX APIs that are implemented in JavaScript using DOM APIs.\\n\\n### Project Overview\\n\\n* `main.c` - Imports `stdio.h` and calls `printf(\\"Hello World\\")`.\\n* `main.js` - Initializes a runtime environment for the WebAssembly module and implements the necessary WebAssembly imports.\\n\\n### Things to Explore\\n\\n1. Click Build to compile `main.c` file to `out/main.wasm`.\\n\\n2. Open the `out/main.wasm` file and notice that there\'s quite a bit of code. This is somewhat surprising given that our program is so small. The vast majority of this code implements the `printf` function. \\n\\n3. Notice the imports section, these are SysCalls. To get this WebAssembly module running you\'ll have to implement these functions first. However, note that these import names don\'t actually tell you what SysCalls are used, they are merely function stubs (one for each number of parameters). \\n\\n```\\n  (import \\"env\\" \\"__syscall0\\" (func $env.__syscall0 (type $t2)))\\n  (import \\"env\\" \\"__syscall3\\" (func $env.__syscall3 (type $t5)))\\n  (import \\"env\\" \\"__syscall1\\" (func $env.__syscall1 (type $t8)))\\n  ...\\n```\\n\\n4. To figure that out which SysCalls are being used, you\'ll have to run the module. I ran it and got `45`, `146` and `192`. You can figure out what these numbers mean by looking them up in the [Linux SysCall Reference](https://syscalls.kernelgrok.com/). They are [brk()](http://man7.org/linux/man-pages/man2/brk.2.html), [writev()](http://man7.org/linux/man-pages/man2/writev.2.html) and [mmap()](http://man7.org/linux/man-pages/man2/mmap2.2.html). To make this WebAssembly module run, you\'ll just have to implement a tiny Linux kernel in JavaScript, no biggie.\\n\\n5. Take a look at `src/main.js`, this file emulates these basic SysCalls in JavaScript.\\n\\n6. `brk()` can be stubbed to return `0`, which is the success error code. `brk()` is used to allocate more memory to a process. WebAssembly does handles memory differently, so there\'s no need to do special here. \\n\\n7. `mmap2()` is used to request more memory within the process. In our example, it\'s implemented as a call to the WebAssembly `memory.grow()` function.\\n\\n8. `writev()` is used to write data to files. Its signature is `writev(int fd, const struct iovec *iov, int iovcnt)`. We can ignore the `fd` file descriptor parameter, and focus on the `iov` structure. The problem here is that on the JavaScript side we have a hard time pulling the `struct iovec` abart. We could figure it out, but a neat hack is to call back into the WebAssembly module and have some C code unpack it for us.\\n\\n9. Click Run\\n\\n```\\nHello World\\n```","type":"text"},{"name":"build.ts","data":"import * as gulp from \\"gulp\\";\\nimport { Service, project } from \\"@wasm/studio-utils\\";\\n\\ngulp.task(\\"build\\", async () => {\\n  const data = await Service.compileFile(project.getFile(\\"src/main.c\\"), \\"c\\", \\"wasm\\", \\"-g -O3\\");\\n  const outWasm = project.newFile(\\"out/main.wasm\\", \\"wasm\\", true);\\n  outWasm.setData(data);\\n});\\n\\ngulp.task(\\"default\\", [\\"build\\"], async () => {});\\n","type":"text"},{"name":"package.json","data":"{\\n  \\"name\\": \\"@wasm/hello_world_c\\",\\n  \\"description\\": \\"\\",\\n  \\"version\\": \\"1.0.0\\",\\n  \\"scripts\\": {\\n    \\"build\\": \\"gulp --gulpfile ./build.ts\\"\\n  },\\n  \\"devDependencies\\": {\\n    \\"@wasm/studio-utils\\": \\"*\\",\\n    \\"gulp\\": \\"~3.9.1\\",\\n    \\"ts-node\\": \\"~5.0.0\\",\\n    \\"typescript\\": \\"~2.7.2\\"\\n  },\\n  \\"wasmStudio\\": {\\n    \\"name\\": \\"Hello World in C\\",\\n    \\"description\\": \\"# Hello World in C\\\\n\\\\nPrint \\\\\\\\`Hello World\\\\\\\\` using a minimal POSIX API.\\\\nLevel: *Advanced*\\\\nTopics: Low-Level, Memory, Linux, System Calls\\",\\n    \\"icon\\": \\"c-lang-file-icon\\"\\n  }\\n}","type":"text"},{"name":"src/main.c","data":"#include <stdio.h>\\n#include <sys/uio.h>\\n\\n#define WASM_EXPORT __attribute__((visibility(\\"default\\")))\\n\\nWASM_EXPORT\\nint main(void) {\\n  printf(\\"Hello World\\\\n\\");\\n}\\n\\n/* External function that is implemented in JavaScript. */\\nextern void putc_js(char c);\\n\\n/* Basic implementation of the writev sys call. */ \\nWASM_EXPORT\\nsize_t writev_c(int fd, const struct iovec *iov, int iovcnt) {\\n  size_t cnt = 0;\\n  for (int i = 0; i < iovcnt; i++) {\\n    for (int j = 0; j < iov[i].iov_len; j++) {\\n      putc_js(((char *)iov[i].iov_base)[j]);\\n    }\\n    cnt += iov[i].iov_len;\\n  }\\n  return cnt;\\n}\\n","type":"text"},{"name":"src/main.html","data":"<!DOCTYPE html>\\n<html>\\n<head>\\n  <meta charset=\'utf-8\'>\\n  <style>\\n    body {\\n        background-color: green;\\n    }\\n  </style>\\n</head>\\n<body>\\n  <span id=\\"container\\"></span>\\n  <script src=\\"./main.js\\"></script>\\n</body>\\n</html>","type":"text"},{"name":"src/main.js","data":"let x = \'../out/main.wasm\';\\n\\nlet instance = null;\\nlet memoryStates = new WeakMap();\\n\\nfunction syscall(instance, n, args) {\\n  switch (n) {\\n    default:\\n      // console.log(\\"Syscall \\" + n + \\" NYI.\\");\\n      break;\\n    case /* brk */ 45: return 0;\\n    case /* writev */ 146:\\n      return instance.exports.writev_c(args[0], args[1], args[2]);\\n    case /* mmap2 */ 192:\\n      debugger;\\n      const memory = instance.exports.memory;\\n      let memoryState = memoryStates.get(instance);\\n      const requested = args[1];\\n      if (!memoryState) {\\n        memoryState = {\\n          object: memory,\\n          currentPosition: memory.buffer.byteLength,\\n        };\\n        memoryStates.set(instance, memoryState);\\n      }\\n      let cur = memoryState.currentPosition;\\n      if (cur + requested > memory.buffer.byteLength) {\\n        const need = Math.ceil((cur + requested - memory.buffer.byteLength) / 65536);\\n        memory.grow(need);\\n      }\\n      memoryState.currentPosition += requested;\\n      return cur;\\n  }\\n}\\n\\nlet s = \\"\\";\\nfetch(x).then(response =>\\n  response.arrayBuffer()\\n).then(bytes =>\\n  WebAssembly.instantiate(bytes, {\\n    env: {\\n      __syscall0: function __syscall0(n) { return syscall(instance, n, []); },\\n      __syscall1: function __syscall1(n, a) { return syscall(instance, n, [a]); },\\n      __syscall2: function __syscall2(n, a, b) { return syscall(instance, n, [a, b]); },\\n      __syscall3: function __syscall3(n, a, b, c) { return syscall(instance, n, [a, b, c]); },\\n      __syscall4: function __syscall4(n, a, b, c, d) { return syscall(instance, n, [a, b, c, d]); },\\n      __syscall5: function __syscall5(n, a, b, c, d, e) { return syscall(instance, n, [a, b, c, d, e]); },\\n      __syscall6: function __syscall6(n, a, b, c, d, e, f) { return syscall(instance, n, [a, b, c, d, e, f]); },\\n      putc_js: function (c) {\\n        c = String.fromCharCode(c);\\n        if (c == \\"\\\\n\\") {\\n          console.log(s);\\n          s = \\"\\";\\n        } else {\\n          s += c;\\n        }\\n      }\\n    }\\n  })\\n).then(results => {\\n  instance = results.instance;\\n  document.getElementById(\\"container\\").textContent = instance.exports.main();\\n}).catch(console.error);\\n","type":"text"}]}'
